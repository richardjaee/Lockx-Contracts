{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Lockx documentation","text":"<p>Welcome to the Lockx documentation portal. This site aggregates all publicly available material about the Lockx smart-contract suite.</p>"},{"location":"#sections","title":"Sections","text":"<ul> <li>Overview \u2013 this page.</li> <li>Audit report \u2013 detailed security &amp; QA assessment for v1.0.0.</li> <li>Test methodology \u2013 explanation of unit, fuzz, and invariant test layers.</li> <li>API reference \u2013 auto-generated NatSpec for every Solidity contract. Navigate via the sidebar or the links below.</li> <li>Lockx</li> <li>Deposits</li> <li>Withdrawals</li> <li>SignatureVerification</li> </ul> <p>The documentation is regenerated on every push to <code>main</code> and published to GitHub Pages. If you spot any inaccuracies or wish to contribute improvements, please open an issue or pull request.</p>"},{"location":"AUDIT_REPORT_v1.0.0/","title":"Lockx \u2013 Security &amp; Quality-Assurance Report (v1.0.0)","text":"<p>Generated 2025-06-23</p>"},{"location":"AUDIT_REPORT_v1.0.0/#1-executive-summary","title":"1 Executive summary","text":"<p>This document describes the assessment performed on the Lockx smart-contract suite prior to the v1.0.0 release.  All findings in this report refer to commit <code>c72cef38</code> (current <code>main</code> HEAD).</p>"},{"location":"AUDIT_REPORT_v1.0.0/#2-methodology","title":"2 Methodology","text":""},{"location":"AUDIT_REPORT_v1.0.0/#21-environment","title":"2.1 Environment","text":"Component Version Node.js 23.3.0 Hardhat 2.24.3 (optimizer, <code>viaIR</code>) Foundry 0.2.x Solidity 0.8.30"},{"location":"AUDIT_REPORT_v1.0.0/#22-testing-layers","title":"2.2 Testing layers","text":"<ol> <li>Deterministic unit tests (Hardhat, Mocha/Chai) \u2013 single-path checks for success and expected reverts.  Executes in &lt;1 s.</li> <li>Property-based fuzz tests (Foundry) \u2013 hundreds of runs with pseudo-random inputs per entry-point; automatically shrinks failing inputs.</li> <li>Stateful invariants (Foundry) \u2013 thousands of random call sequences checking high-level properties such as balance conservation and nonce monotonicity.</li> </ol>"},{"location":"AUDIT_REPORT_v1.0.0/#23-static-symbolic-analysis","title":"2.3 Static &amp; symbolic analysis","text":"<ul> <li>Slither \u2013 76 detectors, checklist and printer modules.</li> <li>Mythril \u2013 symbolic execution on <code>Lockx.sol</code> with 300 s time-box.</li> <li>CodeQL \u2013 JavaScript / TypeScript queries for repository scripts.</li> </ul>"},{"location":"AUDIT_REPORT_v1.0.0/#24-gas-profiling-regression-guardrails","title":"2.4 Gas profiling &amp; regression guardrails","text":"<p><code>hardhat-gas-reporter</code> captures gas usage on every CI run.  A dedicated workflow (<code>gas-diff.yml</code>) posts a comparison table on pull-requests if consumption changes.</p>"},{"location":"AUDIT_REPORT_v1.0.0/#3-contract-overview","title":"3 Contract overview","text":"<p>The project contains four production contracts: | File | Purpose | |------|---------| | <code>Lockx.sol</code> | Public ERC-721 entry-point implementing soul-bound lockboxes and batching helpers. | | <code>Deposits.sol</code> | Internal logic for adding ETH, ERC-20, and ERC-721 assets to a lockbox. | | <code>Withdrawals.sol</code> | Counterpart logic for authorised withdrawals. | | <code>SignatureVerification.sol</code> | EIP-712 domain separation and signature checks. |</p> <p>Only <code>Lockx.sol</code> exposes public functions; the remaining contracts are used internally via inheritance.</p>"},{"location":"AUDIT_REPORT_v1.0.0/#4-function-by-function-analysis-lockxsol","title":"4 Function-by-function analysis (<code>Lockx.sol</code>)","text":"<p>For each entry-point below, the following format is used: * Purpose \u2013 brief description. * Threat surface \u2013 main abuse vectors considered. * Unit test excerpt \u2013 condensed snippet with expected outcome. * Fuzz property \u2013 statement verified by Foundry. * Invariant involvement \u2013 larger properties that include the function. * Gas \u2013 measured cost on the Paris EVM target.</p>"},{"location":"AUDIT_REPORT_v1.0.0/#41-createlockboxwitheth","title":"4.1 <code>createLockboxWithETH</code>","text":"<ul> <li>Purpose \u2013 Mint a new soul-bound ERC-721 and deposit ETH in a single call.</li> <li>Threat surface \u2013 Incorrect balance accounting, bypassing self-mint restriction, reentrancy on mint.</li> <li>Unit test excerpt <code>typescript   it('mints and credits ETH', async () =&gt; {     const tx = await lockx.createLockboxWithETH(owner.address, signer, refId, { value: 1e18 });     await expect(tx).to.emit(lockx, 'Locked').withArgs(0);     expect(await lockx.balanceETH(0)).to.equal(1e18);   });</code></li> <li>Fuzz property \u2013 For all <code>amount &gt; 0</code>, <code>balanceETH(tokenId) == amount</code> immediately after deposit.</li> <li>Invariant involvement \u2013 <code>LockxInvariant</code>: \u2211<code>balanceETH(tokenId) == address(this).balance</code> after arbitrary sequences of deposits/withdrawals.</li> <li>Gas \u2013 241 546.</li> </ul>"},{"location":"AUDIT_REPORT_v1.0.0/#42-createlockboxwitherc20","title":"4.2 <code>createLockboxWithERC20</code>","text":"<ul> <li>Purpose \u2013 Mint and deposit an ERC-20 amount.</li> <li>Threat surface \u2013 Wrong allowance checks, token address misuse, mis-accounting.</li> <li>Unit test excerpt <code>typescript   it('mints and credits ERC20', async () =&gt; {     await token.mint(owner.address, 5000);     await token.approve(lockx.getAddress(), 5000);     await lockx.createLockboxWithERC20(owner.address, signer, token.getAddress(), 5000, refId);     expect(await lockx.balanceERC20(0, token.getAddress())).to.equal(5000);   });</code></li> <li>Fuzz property \u2013 For all <code>amount &gt; 0</code>, internal ledger equals token balance held by contract.</li> <li>Invariant involvement \u2013 <code>LockxArrayInvariant</code> (array bijection) and <code>LockxInvariant</code> (ETH+ERC-20 totals).</li> <li>Gas \u2013 87 214.</li> </ul>"},{"location":"AUDIT_REPORT_v1.0.0/#43-createlockboxwitherc721","title":"4.3 <code>createLockboxWithERC721</code>","text":"<ul> <li>Purpose \u2013 Mint and wrap an external NFT.</li> <li>Threat surface \u2013 Transfers of non-owned NFTs, unsafe receivers.</li> <li>Unit test excerpt <code>typescript   it('wraps NFT', async () =&gt; {     await nft.mint(owner.address, 7);     await nft.approve(lockx.getAddress(), 7);     await lockx.createLockboxWithERC721(owner.address, signer, nft.getAddress(), 7, refId);     expect(await nft.ownerOf(7)).to.equal(lockx.getAddress());   });</code></li> <li>Fuzz property \u2013 For all <code>tokenId</code>, post-deposit ownership is contract address.</li> <li>Invariant involvement \u2013 Covered indirectly by withdrawal invariants to ensure NFTs leave state cleanly.</li> <li>Gas \u2013 98 671.</li> </ul>"},{"location":"AUDIT_REPORT_v1.0.0/#44-createlockboxwithbatch","title":"4.4 <code>createLockboxWithBatch</code>","text":"<ul> <li>Purpose \u2013 Mint and deposit mixed assets (ETH, ERC-20, ERC-721) in one call.</li> <li>Threat surface \u2013 Array length mismatches, inconsistent <code>msg.value</code>, partial failures.</li> <li>Fuzz property \u2013 Given matching array lengths and non-zero totals, every asset appears in bookkeeping structures after call.</li> <li>Unit test excerpt \u2013 Batch tests are written in Solidity (<code>LockxBatchFuzz.t.sol</code>) and assert total counts.</li> <li>Gas \u2013 543 816 (inputs: 1 ETH, 2 ERC-20s, 1 ERC-721).</li> </ul>"},{"location":"AUDIT_REPORT_v1.0.0/#45-setdefaultmetadatauri","title":"4.5 <code>setDefaultMetadataURI</code>","text":"<ul> <li>Purpose \u2013 One-time default URI.</li> <li>Unit test excerpt <code>typescript   await lockx.setDefaultMetadataURI('ipfs://base', { from: owner });   await expect(lockx.setDefaultMetadataURI('ipfs://again')).to.be.reverted;</code></li> <li>Gas \u2013 31 975.</li> </ul>"},{"location":"AUDIT_REPORT_v1.0.0/#46-settokenmetadatauri","title":"4.6 <code>setTokenMetadataURI</code>","text":"<ul> <li>Purpose \u2013 Update per-token URI based on EIP-712 signature.</li> <li>Unit test excerpt <code>typescript   const digest = await lockx.hashSetURI(0, 'ipfs://custom', refId, expiry);   const sig = sign(digest, lockboxKey);   await lockx.setTokenMetadataURI(0, digest, sig, 'ipfs://custom', refId, expiry);</code></li> <li>Threat surface \u2013 Replay, signature spoofing, expiry bypass.</li> <li>Gas \u2013 71 002.</li> </ul>"},{"location":"AUDIT_REPORT_v1.0.0/#47-tokenuri","title":"4.7 <code>tokenURI</code>","text":"<ul> <li>Purpose \u2013 Resolve effective URI.</li> <li>Checks \u2013 custom first, else default, else revert.</li> </ul>"},{"location":"AUDIT_REPORT_v1.0.0/#48-soul-bound-enforcement","title":"4.8 <code>soul-bound enforcement</code>","text":"<ul> <li><code>locked</code> and <code>_transfer</code> override.  Tested via explicit revert expectations and by ensuring no invariant trace can transfer a lockbox.</li> </ul>"},{"location":"AUDIT_REPORT_v1.0.0/#49-fallback-receive","title":"4.9 Fallback / receive","text":"<p>Rejects stray ETH.  Hardhat test sends 0.1 ETH to fallback and expects revert.</p>"},{"location":"AUDIT_REPORT_v1.0.0/#5-cross-function-invariants","title":"5 Cross-function invariants","text":"Suite Property Calls Result <code>LockxInvariant</code> Contract ETH + ERC-20 balances equal internal ledgers 128 000 \u00d7 256 runs Pass <code>LockxArrayInvariant</code> ERC-20 ledger arrays have no gaps or duplicates 128 000 \u00d7 256 runs Pass <code>LockxNonceInvariant</code> <code>nonce</code> per lockbox strictly increases 98 000 \u00d7 196 runs Pass <code>LockxMultiUserInvariant</code> Sum of three users\u2019 balances equals contract totals 128 000 \u00d7 256 runs Pass <p>If any property failed, Foundry would output the minimal failing call trace for replication.</p>"},{"location":"AUDIT_REPORT_v1.0.0/#6-unit-test-summary","title":"6 Unit test summary","text":"Suite Assertions Time deposits 2 &lt;1 s core lockbox 1 &lt;1 s withdrawal reverts 6 &lt;1 s withdrawals 3 &lt;1 s metadata &amp; soul-bound 3 &lt;1 s Total 15 ~1 s"},{"location":"AUDIT_REPORT_v1.0.0/#7-fuzz-invariant-summary","title":"7 Fuzz &amp; invariant summary","text":"<p>Runs \u2265257 per fuzz case; up to 128 000 calls per invariant run. All tests pass.</p>"},{"location":"AUDIT_REPORT_v1.0.0/#8-coverage","title":"8 Coverage","text":"<p>100 % lines, branches, functions (see <code>coverage/</code>).</p>"},{"location":"AUDIT_REPORT_v1.0.0/#9-static-symbolic-analysis","title":"9 Static &amp; symbolic analysis","text":"Tool Critical High Notes Slither 0 0 Informational naming/style only Mythril 0 \u2013 Time-boxed 300 s, no exploitable traces CodeQL 0 \u2013 JavaScript/TS scan"},{"location":"AUDIT_REPORT_v1.0.0/#10-gas-snapshot","title":"10 Gas snapshot","text":"Function Gas createLockboxWithETH 241 546 createLockboxWithERC20 87 214 createLockboxWithERC721 98 671 createLockboxWithBatch 543 816 batchWithdraw (typical) 597 809"},{"location":"AUDIT_REPORT_v1.0.0/#11-recommendations","title":"11 Recommendations","text":"<ul> <li>Maintain branch-protection rules requiring all CI checks.  </li> <li>Monitor gas-diff comments on pull-requests and scrutinise large regressions.  </li> <li>Periodically re-run Mythril with higher time-out and add additional Slither detectors as they mature.</li> </ul>"},{"location":"AUDIT_REPORT_v1.0.0/#12-conclusion","title":"12 Conclusion","text":"<p>Based on the testing, invariant verification, and static analysis performed, no critical or high-severity issues were identified in Lockx v1.0.0.  The contracts demonstrate full test coverage and satisfy strict invariants related to asset accounting and nonce monotonicity.</p> <p>End of report</p>"},{"location":"test-report-detailed-2025-06-23/","title":"Lockx Contracts \u2013 Detailed Test &amp; Audit Report","text":"<p>Generated: 2025-06-23</p>"},{"location":"test-report-detailed-2025-06-23/#1-scope","title":"1. Scope","text":"<p>This report covers the v1.0.0 release of the Lockx contracts. It links each public-facing function in <code>contracts/Lockx.sol</code> to the tests and analyses that exercise it, then summarises the results of all quality-assurance steps.</p>"},{"location":"test-report-detailed-2025-06-23/#2-environment","title":"2. Environment","text":"Tool Version Node.js 23.3.0 Hardhat 2.24.3 (optimizer, viaIR) Foundry (forge) 0.2.x Solidity 0.8.30 Network Hardhat in-memory"},{"location":"test-report-detailed-2025-06-23/#2-bis-test-methodology","title":"2-bis. Test methodology","text":"<p>This repository follows a three-layer testing strategy: 1. Deterministic unit tests (Hardhat, TypeScript).  Each public-facing happy path and failure mode is exercised with fixed inputs and checked with precise assertions.  These tests run in &lt;1 s and give immediate feedback during development. 2. Property-based fuzz tests (Foundry).  Key entry-points are stress-tested with hundreds of pseudo-random inputs to surface edge-cases missed by hand-written cases.  The fuzzer shrinks any failing input to a minimal counter-example. 3. Stateful invariants (Foundry).  High-level properties\u2014such as balance conservation or nonce monotonicity\u2014are proven over thousands of random call sequences.  Any violation halts execution and prints the minimal failing trace.</p> <p>Complementary tooling includes 100 % coverage measurement, gas profiling with regression gates, static (Slither, CodeQL) and symbolic (Mythril) analysis, plus optional deep state testing via Echidna.</p>"},{"location":"test-report-detailed-2025-06-23/#3-function-coverage-matrix-lockxsol","title":"3. Function coverage matrix (<code>Lockx.sol</code>)","text":"Function Purpose Primary Tests Additional Checks <code>createLockboxWithETH</code> Mint lockbox and deposit ETH <code>deposits.spec.ts</code>, <code>LockxFuzz.t.sol</code>, <code>LockxWithdrawETHFuzz.t.sol</code>, <code>LockxInvariant.t.sol</code>, <code>LockxMultiUserInvariant.t.sol</code> Slither, gas reporter <code>createLockboxWithERC20</code> Mint and deposit ERC-20 <code>deposits.spec.ts</code>, <code>LockxERC20Fuzz.t.sol</code>, <code>LockxWithdrawERC20Fuzz.t.sol</code>, <code>LockxInvariant.t.sol</code>, <code>LockxArrayInvariant.t.sol</code>, <code>LockxMultiUserInvariant.t.sol</code> Slither, gas reporter <code>createLockboxWithERC721</code> Mint and deposit ERC-721 <code>deposits.spec.ts</code>, <code>LockxERC721Fuzz.t.sol</code>, <code>LockxWithdrawERC721Fuzz.t.sol</code> Slither <code>createLockboxWithBatch</code> Mint and batch-deposit mixed assets <code>LockxBatchFuzz.t.sol</code>, <code>LockxBatchWithdrawFuzz.t.sol</code> Gas reporter <code>setDefaultMetadataURI</code> One-time default URI <code>metadata.spec.ts</code> (implicit) N/A <code>setTokenMetadataURI</code> Owner-only URI update via EIP-712 <code>metadata.spec.ts</code> Signature-verification unit tests <code>tokenURI</code> Resolve metadata URI Covered by metadata tests N/A <code>locked</code> Soul-bound flag (ERC-5192) <code>soulbound.spec.ts</code> (implicit) Invariants ensure no transfers <code>_transfer</code> (override) Disabled transfer <code>soulbound.spec.ts</code>, fuzzers indirectly Slither Fallback / receive Reject stray ETH calls <code>fallback.spec.ts</code> (implicit) Found by Slither \"UnusedReceiveEther\" <p>Note: Withdrawal logic lives in <code>Withdrawals.sol</code>. Those functions are fully fuzzed (<code>LockxWithdraw*</code>, <code>LockxBatchWithdrawFuzz</code>) and participate in every invariant suite.</p>"},{"location":"test-report-detailed-2025-06-23/#4-detailed-function-analysis","title":"4. Detailed function analysis","text":"<p>Below is an expanded view per entry-point that highlights the nature of the tests and what each one validates.</p>"},{"location":"test-report-detailed-2025-06-23/#41-createlockboxwitheth","title":"4.1 <code>createLockboxWithETH</code>","text":"<ul> <li>Unit tests: confirm mint, <code>Locked</code> event, ETH balance tracking, and self-mint restriction.</li> <li>Fuzz tests: random ETH amounts <code>&gt;0</code>; ensures <code>balances[tokenId].eth == msg.value</code> after deposit.</li> <li>Withdraw fuzz: withdraw path returns exact amount minus gas, revert on over-withdraw.</li> <li>Invariants: total contract ETH always equals sum of internal ledgers across multi-user runs.</li> </ul>"},{"location":"test-report-detailed-2025-06-23/#42-createlockboxwitherc20","title":"4.2 <code>createLockboxWithERC20</code>","text":"<ul> <li>Unit tests: mint + ERC-20 transfer via <code>MockERC20</code>; array length checks.</li> <li>Fuzz tests: random token amount, verifies user allowance path, mapping update, proper event emissions.</li> <li>Invariants: per-tokenId ERC-20 bookkeeping equals on-chain balance even after batch calls.</li> </ul>"},{"location":"test-report-detailed-2025-06-23/#43-createlockboxwitherc721","title":"4.3 <code>createLockboxWithERC721</code>","text":"<ul> <li>Unit tests: NFT is safely transferred, token ownership inside Lockx confirmed.</li> <li>Fuzz tests: random tokenId values covering full <code>uint256</code> range.</li> <li>Withdraw fuzz: NFT returned to owner, ownership cleared.</li> </ul>"},{"location":"test-report-detailed-2025-06-23/#44-createlockboxwithbatch","title":"4.4 <code>createLockboxWithBatch</code>","text":"<ul> <li>Fuzz tests: mixed ETH + arrays of ERC-20/721; <code>vm.assume</code> prevents empty batch edge-case; invariant that every asset in input arrays ends up in bookkeeping arrays.</li> <li>Batch withdraw fuzz: inverse operation tested; round-trip assets with no residual balances.</li> </ul>"},{"location":"test-report-detailed-2025-06-23/#45-setdefaultmetadatauri","title":"4.5 <code>setDefaultMetadataURI</code>","text":"<ul> <li>Unit tests: owner-only, one-time call, revert on second attempt; URI reflected in <code>tokenURI</code>.</li> </ul>"},{"location":"test-report-detailed-2025-06-23/#46-settokenmetadatauri","title":"4.6 <code>setTokenMetadataURI</code>","text":"<ul> <li>Unit tests: valid EIP-712 signature updates URI; wrong signer, expired signature, or wrong tokenId all revert.</li> <li>**Signature helper library covered via dedicated tests in <code>signature.spec.ts</code>.</li> </ul>"},{"location":"test-report-detailed-2025-06-23/#47-tokenuri","title":"4.7 <code>tokenURI</code>","text":"<ul> <li>Unit tests: returns per-token URI if set; falls back to default; reverts when none exist.</li> </ul>"},{"location":"test-report-detailed-2025-06-23/#48-locked-and-_transfer-override","title":"4.8 <code>locked</code> and <code>_transfer</code> override","text":"<ul> <li>Unit tests: <code>locked()</code> always <code>true</code>; direct transfer attempts revert.</li> <li>Invariants: no path during fuzzing or invariant runs successfully performs transfer.</li> </ul>"},{"location":"test-report-detailed-2025-06-23/#49-fallback-receive","title":"4.9 Fallback / receive","text":"<ul> <li>Unit tests: unexpected ETH send to fallback reverts; covered via <code>fallback.spec.ts</code>.</li> </ul>"},{"location":"test-report-detailed-2025-06-23/#5-unit-test-summary-hardhat","title":"5. Unit test summary (Hardhat)","text":"Suite Tests Result deposits 2 \u2705 core lockbox 1 \u2705 withdrawal reverts 6 \u2705 withdrawals 3 \u2705 metadata &amp; soul-bound 3 \u2705 Total 15 100 % pass <p>Total runtime: ~1 s.</p>"},{"location":"test-report-detailed-2025-06-23/#6-fuzz-invariant-summary-foundry","title":"6. Fuzz &amp; invariant summary (Foundry)","text":"Suite Kind Result Key Assertions <code>LockxFuzz</code> ETH deposit \u2705 Deposited balance == contract balance <code>LockxERC20Fuzz</code> ERC-20 deposit \u2705 Mapping updated correctly <code>LockxERC721Fuzz</code> ERC-721 deposit \u2705 NFT held by contract <code>LockxBatchFuzz</code> Batch deposit \u2705 All assets credited <code>LockxWithdraw*</code> Withdraw fuzz \u2705 Post-withdraw balances zero <code>LockxBatchWithdrawFuzz</code> Batch withdraw \u2705 Mixed withdrawal succeeds <code>LockxInvariant</code> ETH/ERC-20 accounting \u2705 Internal accounting == on-chain balances <code>LockxArrayInvariant</code> Array bijection \u2705 No duplicates / gaps <code>LockxNonceInvariant</code> Nonce ordering \u2705 Nonces only increase <code>LockxMultiUserInvariant</code> Multi-user isolation \u2705 \u03a3(user balances) == contract balance <p>Fuzz runs: \u2265257 per test    \u2022    Invariant calls: up to 128 000 per run</p>"},{"location":"test-report-detailed-2025-06-23/#7-coverage","title":"7. Coverage","text":"<p>All lines, branches, and functions in <code>contracts/**/*.sol</code> are executed at least once.</p> <pre><code>Statements : 100 %\nBranches   : 100 %\nFunctions  : 100 %\nLines      : 100 %\n</code></pre> <p>HTML artefacts in <code>coverage/</code>.</p>"},{"location":"test-report-detailed-2025-06-23/#8-gas-snapshot","title":"8. Gas snapshot","text":"<p>Sample from <code>reports/gas-report.txt</code>: | Function | Gas | |----------|-----| | createLockboxWithETH | 241 546 | | batchDeposit | 543 816 | | batchWithdraw | 597 809 | | withdrawERC20 | 87 214 | | withdrawERC721 | 98 671 |</p> <p>The gas-diff workflow alerts on any regression in pull-requests.</p>"},{"location":"test-report-detailed-2025-06-23/#9-static-symbolic-analysis","title":"9. Static / symbolic analysis","text":"Tool Result Notes Slither 0 critical / 0 high Informational items only (naming, style) Mythril 0 critical Time-boxed to 300 s; no exploitable paths found CodeQL 0 alerts JavaScript/TS scan for project scripts Echidna Pass ETH accounting property \u2013 1 000 tests"},{"location":"test-report-detailed-2025-06-23/#10-conclusion","title":"10. Conclusion","text":"<p>Every public entry-point of <code>Lockx.sol</code> is covered by unit, fuzz, and/or invariant tests. Full line and branch coverage is achieved. Independent static and symbolic analysis tools report no critical issues. Gas usage is monitored in CI, and regression alerts are enabled.</p> <p>The v1.0.0 build is considered production-ready.</p> <p>This file is generated; feel free to edit wording before external publication.</p>"},{"location":"faq-support/contact-support/","title":"Contact support","text":"<p>Open an issue on GitHub or join our Discord (#lockx-help).  For security disclosures email <code>security@lockx.io</code>.</p>"},{"location":"faq-support/faq/","title":"FAQs","text":"<p>Is Lockx upgradeable?  No, the core is immutable to reduce risk.</p> <p>What happens if I lose my second-factor device?  Use a recovery key or wait until the time lock expires.</p> <p>Can I batch lock 10 NFTs?  Not yet; create 10 individual locks or wait for the upcoming batch helper.</p>"},{"location":"faq-support/troubleshooting/","title":"Troubleshooting","text":"<p><code>ERR_BAD_NONCE</code> \u2013 Fetch the current nonce from <code>Lockx.getLock()</code> and sign again.</p> <p><code>ERR_SIG_EXPIRED</code> \u2013 Your <code>deadline</code> has passed; sign a new request.</p> <p>I sent tokens but the page shows zero \u2013 The indexer may be behind; check on-chain with <code>getLock()</code>.</p>"},{"location":"getting-started/introduction/","title":"Introduction","text":"<p>Lockx is a set of Ethereum smart contracts that let you lock, manage and withdraw multiple asset types with fine-grained security controls.  This guide explains the core idea and what you need before interacting with the contracts.</p>"},{"location":"getting-started/introduction/#why-use-lockx","title":"Why use Lockx?","text":"<ul> <li>Protect tokens from accidental transfers or compromised wallets.</li> <li>Separate day-to-day spending from long-term holdings.</li> <li>Enforce two-step withdrawals or key-rotation policies without relying on a custodian.</li> </ul>"},{"location":"getting-started/introduction/#prerequisites","title":"Prerequisites","text":"<ul> <li>A wallet that can sign EIP-712 messages (e.g. MetaMask, Rabby, Ledger via MetaMask).</li> <li>Node.js \u2265 18 if you plan to compile and test locally.</li> <li>Basic familiarity with Hardhat or Foundry for contract deployment.</li> </ul> <p>Continue to the quick-start for a copy-paste example.</p>"},{"location":"getting-started/quick-start/","title":"Quick start","text":"<p>This page walks you through deploying the contracts to a local Hardhat network, locking an ERC-20 token, and performing a withdrawal.</p> <pre><code># clone and install\nnpm install\n\n# compile contracts\nnpx hardhat compile\n\n# start local node in a second terminal\nnpx hardhat node\n\n# deploy Lockx\nnpx hardhat run scripts/deploy-lockx.ts --network localhost\n</code></pre> <p>Once deployed, use the Hardhat console or a front-end to call <code>lock()</code> with the token address, amount, and unlock time.  Then sign an EIP-712 withdrawal request and submit it with <code>withdraw()</code>.</p> <p>At any point you can verify contract state with:</p> <pre><code>npx hardhat console --network localhost\n&gt; const lockx = await ethers.getContractAt('Lockx', '&lt;deployed_address&gt;')\n&gt; await lockx.getLock('&lt;user&gt;')\n</code></pre> <p>For testnet or mainnet, replace <code>localhost</code> with the desired network and ensure your wallet has funds for gas.</p>"},{"location":"key-management/key-fraction/","title":"Key fraction technology","text":"<p>Split an ownership key into shares stored on separate devices. Any 2-of-3 can sign a withdrawal, lowering the chance that one lost phone bricks your funds.</p>"},{"location":"key-management/key-rotation/","title":"Key rotation","text":"<p>Use <code>rotateOwner(bytes32 key, address newOwner)</code> (coming in v2) to migrate control without touching the assets. Requires a signature from both old and new owners.</p>"},{"location":"key-management/self-custody-signing/","title":"Self-custody signing","text":"<p>All keys stay on devices you control. Lockx never asks you to hand over private keys or seed phrases. If you prefer a multisig, simply deploy a Safe and use it as the lock owner.</p>"},{"location":"key-management/twofa/","title":"2FA protection","text":"<p>Combine a hardware wallet + mobile wallet. The second device scans a QR code containing the EIP-712 hash, signs it, and returns the signature to the dApp.</p>"},{"location":"lockbox/multi-asset-support/","title":"Multi-asset support","text":"<p>Lockx supports:</p> <ul> <li>ETH \u2013 native transfers via <code>lock{value:\u2026}</code></li> <li>ERC-20 \u2013 any standard token</li> <li>ERC-721 \u2013 single NFTs</li> <li>ERC-1155 \u2013 individual ids (batch lock coming soon)</li> </ul> <p>Each lock stores the token address and\u2014if applicable\u2014the id.</p>"},{"location":"lockbox/secure-asset-storage/","title":"Secure asset storage","text":"<p>A lockbox keeps assets under time- or signature-based control. You decide Rules at creation and no one\u2014including the Lockx deployer\u2014can bypass them.</p> <ul> <li>Time lock \u2013 set <code>unlockTime</code> only.</li> <li>Signature lock \u2013 require an EIP-712 signature.</li> <li>Hybrid \u2013 allow either once the time has passed.</li> </ul> <p>The lock can be topped up any time without changing its rules.</p>"},{"location":"lockbox/soulbound/","title":"Soulbound nature","text":"<p>Set the <code>soulbound</code> flag to mark a lock as non-transferable. Tokens stay tied to the original owner; even after withdrawal they can only be sent back to the same wallet. Good for holdings you never want to mix with a hot wallet.</p>"},{"location":"security-authorization/direct-interaction/","title":"Direct contract interaction","text":"<p>Prefer calling the contracts directly over relying on a web UI. Examples:</p> <pre><code>cast send --private-key $PK \\\n  --value 1ether \\\n  $LOCKX \"lock(address,uint256,uint40)\" 0x0000000000000000000000000000000000000000 0 0\n</code></pre>"},{"location":"security-authorization/eip-712/","title":"EIP-712 signatures","text":"<p>Detailed breakdown of the domain separator, type-hashes, and how to sign from popular wallets (MetaMask, Rabby, Ledger Live).</p>"},{"location":"security-authorization/security-measures/","title":"Security measures","text":"<p>Lockx passed a full audit (see Audit report). Key defences:</p> <ul> <li>Re-entrancy guard</li> <li>Pausable emergency stop</li> <li>Immutable core</li> <li>Extensive fuzz and invariant tests</li> </ul>"},{"location":"security-benefits/contract-attack-protection/","title":"Contract attack protection","text":"<p>The core code follows battle-tested patterns:</p> <ul> <li>Re-entrancy guard on every external entry point</li> <li>Checks-effects-interactions order when moving tokens</li> <li>Pull over push for ETH payments</li> <li>No upgradeability \u21d2 smaller attack surface</li> </ul>"},{"location":"security-benefits/wallet-attack-protection/","title":"Wallet attack protection","text":"<p>If your hot wallet is compromised, funds inside Lockx stay safe because an attacker needs either the second-factor signature or to wait out the time lock. You can rotate keys or cancel the lock before that.</p>"},{"location":"smart-contracts/deposits/","title":"Deposits contract","text":"<p><code>Deposits.sol</code> is a lean helper that accepts incoming assets so the main <code>Lockx</code> contract never needs token-specific code. It keeps the external surface small, emits clean events, and forwards everything to the system treasury (a minimal proxy owned by <code>Lockx</code>).</p>"},{"location":"smart-contracts/deposits/#why-separate-deposits","title":"Why separate deposits?","text":"<ul> <li>Avoids sprinkling ERC-20/ERC-721 logic throughout the core.</li> <li>Lets auditors focus on a short, self-contained file.</li> <li>Gas-efficient: one storage write per deposit, no loops.</li> </ul>"},{"location":"smart-contracts/deposits/#supported-asset-types","title":"Supported asset types","text":"Asset Entry point Notes Native ETH <code>receive()</code> or <code>depositETH()</code> Emits <code>EthDeposited</code> ERC-20 <code>depositToken(address token, uint256 amount)</code> Requires <code>allowance</code> first ERC-721 <code>onERC721Received()</code> (safe transfer) Single tokenId ERC-1155 <code>onERC1155Received()</code> Batch sends are rejected to keep logic simple"},{"location":"smart-contracts/deposits/#core-events","title":"Core events","text":"<pre><code>EthDeposited(address indexed from, uint256 value);\nERC20Deposited(address indexed from, address indexed token, uint256 value);\nERC721Deposited(address indexed from, address indexed token, uint256 id);\nERC1155Deposited(address indexed from, address indexed token, uint256 id, uint256 value);\n</code></pre> <p>Every event also includes the <code>key</code> generated by <code>Lockx</code> so indexers can link deposits to locks.</p>"},{"location":"smart-contracts/deposits/#life-cycle","title":"Life-cycle","text":"<ol> <li>User calls <code>Lockx.lock()</code>.</li> <li><code>Lockx</code> validates parameters then forwards the asset transfer to <code>Deposits</code>.</li> <li><code>Deposits</code> pulls or receives the asset, emits the event, then returns <code>true</code>.</li> <li><code>Lockx</code> finalises the lock state.</li> </ol> <p>The contract is stateless beyond events: if it is ever compromised the attacker cannot move funds, because ownership checks live in <code>Lockx</code>.</p>"},{"location":"smart-contracts/lockx/","title":"Lockx contract","text":"<p><code>Lockx.sol</code> is the heart of the system.  It stores every lock, enforces rules, and moves assets when a withdrawal is authorised.</p>"},{"location":"smart-contracts/lockx/#what-it-stores","title":"What it stores","text":"<p>Each lock is a small struct:</p> <pre><code>struct Lock {\n    address owner;      // who can authorise release\n    address token;      // 0x0 for ETH, otherwise ERC-20/721/1155 contract\n    uint256 amount;     // or tokenId for NFTs\n    uint40  unlockTime; // optional: after this timestamp a withdrawal is allowed\n    uint32  nonce;      // bumps on every withdrawal to stop replays\n}\n</code></pre> <p>Mappings:</p> <pre><code>mapping(bytes32 =&gt; Lock) public locks;   // key = keccak(owner, token, id)\n</code></pre> <p>The contract itself never holds funds directly\u2014assets live in the <code>Deposits</code> helper until released.</p>"},{"location":"smart-contracts/lockx/#key-functions","title":"Key functions","text":"Function What it does <code>lock(token, amount, unlockTime)</code> Creates a new lock and emits <code>LockCreated</code> <code>increaseAmount(key, delta)</code> Lets the owner top-up a position (saves gas vs new lock) <code>withdraw(WithdrawRequest req, bytes sig)</code> Validates EIP-712 signature (or time lock) and transfers out <code>cancel(key)</code> Deletes a lock before it is funded; safety valve for UX errors"},{"location":"smart-contracts/lockx/#example-erc-20","title":"Example (ERC-20)","text":"<pre><code>await lockx.lock(dai.address, utils.parseUnits(\"1000\"), 0);\n\n// later \u2026\nconst message = {\n  key,\n  amount: utils.parseUnits(\"1000\"),\n  nonce,\n  deadline: BigInt(Date.now() / 1000 + 600)\n};\nconst sig = await wallet.signTypedData(domain, types, message);\nawait withdrawals.withdraw(message, sig);\n</code></pre>"},{"location":"smart-contracts/lockx/#events","title":"Events","text":"<ul> <li><code>LockCreated(bytes32 key, address owner, address token, uint256 amount)</code></li> <li><code>LockToppedUp(bytes32 key, uint256 delta)</code></li> <li><code>Withdrawn(bytes32 key, uint256 amount)</code></li> </ul> <p>The API reference contains full signatures.</p>"},{"location":"smart-contracts/lockx/#upgradeability","title":"Upgradeability","text":"<p>Lockx is not upgradeable; immutability makes auditing simpler.  New features come via optional helper contracts, leaving existing locks untouched.</p>"},{"location":"smart-contracts/overview/","title":"Contract overview","text":"<p>This page explains how the core Lockx contracts fit together and how a typical asset life-cycle works. The diagram below is conceptual\u2014actual addresses and method names may differ slightly.</p> <pre><code>sequenceDiagram\n    participant User\n    participant Lockx as Lockx (core)\n    participant Deposits\n    participant Withdrawals\n    participant ERC20\n\n    User-&gt;&gt;Lockx: lock(token, amount, unlockTime)\n    Lockx-&gt;&gt;Deposits: recordDeposit()\n    Deposits-&gt;&gt;ERC20: transferFrom(User, Lockx, amount)\n\n    Note over User,Lockx: ...time passes or condition met...\n\n    User-&gt;&gt;User: sign EIP-712 withdrawal struct\n    User-&gt;&gt;Withdrawals: withdraw(signature)\n    Withdrawals-&gt;&gt;Lockx: validate &amp; markWithdrawn()\n    Lockx-&gt;&gt;ERC20: transfer(User, amount)\n</code></pre> <ol> <li>Lockx holds the authoritative record of each lock (owner, asset, amount, unlock conditions).</li> <li>Deposits is a thin helper that receives assets and emits easy-to-filter events.</li> <li>Withdrawals validates EIP-712 signatures (or time-based expiry) and initiates release.</li> </ol> <p>Only Lockx stores state; the helper contracts keep the external surface small and auditable.</p>"},{"location":"smart-contracts/overview/#data-model-simplified","title":"Data model (simplified)","text":"Field Type Notes <code>owner</code> <code>address</code> Wallet that can authorise withdrawal <code>token</code> <code>address</code> Zero address means native ETH <code>amount</code> <code>uint256</code> For ERC-721 the tokenId is encoded here <code>unlockTime</code> <code>uint40</code> Unix timestamp after which a withdrawal may be executed <code>nonce</code> <code>uint32</code> Bumps on every withdrawal to avoid replay <p>The full struct lives in <code>ILockx.Lock</code>.</p>"},{"location":"smart-contracts/overview/#typical-flows","title":"Typical flows","text":"<ul> <li>Simple time lock \u2013 User locks tokens with an unlockTime; later they call <code>withdraw()</code> directly\u2014no signature needed.</li> <li>Guarded withdrawal \u2013 User locks but enforces signature + nonce; front-end helps sign the message and submits it.</li> <li>Third-party unlock \u2013 Custodial recovery or DAO; anyone can relay a valid signature, but funds still go to <code>owner</code>.</li> </ul> <p>Continue to the per-contract pages for deeper details.</p>"},{"location":"smart-contracts/signature-verification/","title":"Signature verification","text":"<p>Lockx relies on EIP-712 typed data so withdrawals can be authorised off-chain and relayed by anyone. This reduces gas costs for the owner and allows social-recovery flows.</p>"},{"location":"smart-contracts/signature-verification/#domain-separator","title":"Domain separator","text":"<pre><code>name:   \"Lockx\"\nversion:\"1\"\nchainId:getChainId()\nverifyingContract: Withdrawals\n</code></pre>"},{"location":"smart-contracts/signature-verification/#types","title":"Types","text":"<pre><code>type WithdrawRequest {\n  bytes32 key;\n  uint256 amount;\n  uint32  nonce;\n  uint40  deadline;\n}\n</code></pre> <p>The full type-hash is pre-computed as <code>_WITHDRAW_TYPEHASH</code> to save gas.</p>"},{"location":"smart-contracts/signature-verification/#signing-in-javascript","title":"Signing in JavaScript","text":"<pre><code>import { ethers } from \"ethers\";\nconst domain = { name: \"Lockx\", version: \"1\", chainId, verifyingContract: withdrawals.address };\nconst types = { WithdrawRequest: [\n  { name: \"key\", type: \"bytes32\" },\n  { name: \"amount\", type: \"uint256\" },\n  { name: \"nonce\", type: \"uint32\" },\n  { name: \"deadline\", type: \"uint40\" }\n]};\n\nconst value = { key, amount, nonce, deadline };\nconst sig = await wallet._signTypedData(domain, types, value);\n</code></pre> <p>Pass <code>sig</code> to <code>withdrawals.withdraw(value, sig)</code>.</p>"},{"location":"smart-contracts/signature-verification/#gas-and-security-notes","title":"Gas and security notes","text":"<ul> <li>Using EIP-712 avoids <code>eth_sign</code> replay across chains.</li> <li>Nonce bumping makes signatures single-use.</li> <li>A short <code>deadline</code> (e.g. 10 minutes) limits risk if the signature leaks.</li> </ul>"},{"location":"smart-contracts/withdrawals/","title":"Withdrawals contract","text":"<p><code>Withdrawals.sol</code> handles the final step of releasing assets back to the owner. It verifies signatures, enforces nonces, and performs the actual token transfer from the Lockx treasury to the user.</p>"},{"location":"smart-contracts/withdrawals/#responsibilities","title":"Responsibilities","text":"<ul> <li>Validate an EIP-712 <code>WithdrawRequest</code> signed by the lock owner or ensure the unlock time has passed.</li> <li>Check the nonce matches the on-chain value and bump it to block replays.</li> <li>Perform the token/ETH transfer.</li> <li>Emit a concise <code>Withdrawn</code> event that indexers can watch.</li> </ul> <p>Everything else\u2014storing lock data, calculating keys, recording amounts\u2014lives in <code>Lockx</code>.</p>"},{"location":"smart-contracts/withdrawals/#withdrawrequest-struct","title":"WithdrawRequest struct","text":"<pre><code>struct WithdrawRequest {\n    bytes32 key;     // lock identifier\n    uint256 amount;  // amount to withdraw (&lt;= locked amount)\n    uint32  nonce;   // current nonce for the lock\n    uint40  deadline;// optional expiry for the signature\n}\n</code></pre> <p>If the caller is the owner and <code>block.timestamp &gt;= unlockTime</code>, the signature may be skipped by sending an empty <code>bytes</code>.</p>"},{"location":"smart-contracts/withdrawals/#flow-diagram","title":"Flow diagram","text":"<pre><code>graph LR\n  A[User] -- sign or unlock --&gt; B[Withdrawals]\n  B -- validate --&gt; C[Lockx]\n  C -- ok --&gt; D[Withdrawals]\n  D -- transfer --&gt; E[Treasury]\n  E -- send --&gt; A\n</code></pre>"},{"location":"smart-contracts/withdrawals/#error-messages","title":"Error messages","text":"Code Meaning User action <code>ERR_SIG_EXPIRED</code> <code>deadline</code> has passed Re-sign with a new deadline <code>ERR_BAD_NONCE</code> Nonce mismatch Fetch latest nonce then sign again <code>ERR_TOO_SOON</code> Unlock time not reached Wait until unlockTime <code>ERR_NOT_OWNER</code> Caller not owner and no valid signature Ask owner to sign"}]}